# 链表（上）

## 链表结构

+ 数组需要一块 **连续** 的内存空间来存储，链表恰恰相反，它并 **不需要一块连续** 的内存空间，它通过“指针”将一组零散的内存块串联起来使用。

  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210324155924249.png" alt="image-20210324155924249" style="zoom: 50%;" />

+  **链表类型：** 单链表、双向链表和循环链表。

  + **单链表：** 链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的**“结点”**。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作**后继指针 next**。

    <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="img" style="zoom:50%;" />

    + **插入，删除：** 只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。

    <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/452e943788bdeea462d364389bd08a17.jpg" alt="img" style="zoom: 50%;" />

    + **查找：** 根据指针一个结点一个结点地依次遍历，直到找到相应的结点，**需要 O(n) 的时间复杂度。**

  + **循环链表：** 循环链表的尾结点指针是指向链表的头结点。

    <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/86cb7dc331ea958b0a108b911f38d155.jpg" alt="img" style="zoom:50%;" />

    + 优点：循环链表的优点是从链尾到链头比较方便。当要处理的数据**具有环型结构特点**时，就特别适合采用循环链表。

  + **双向链表：** 支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 `prev` 指向前面的结点。

    <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="img" style="zoom:50%;" />

    + 如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性，**双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点**，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

  + **双向循环链表：**

    <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313104205.jpeg" alt="img" style="zoom: 50%;" />

+ **链表的删除操作：**双向链表的优势
  + 删除结点中“值等于某个给定值”的结点：
    + 不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。**删除O(1)，查找O(n)，总时间复杂度为O(n)**
  + 删除给定指针指向的结点：
    + 我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p->next=q，说明 p 是 q 的前驱结点。
    + 因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！
    + 插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

## 链表 VS 数组性能大比拼

<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313104247.jpeg" alt="img" style="zoom:50%;" />

# 链表（下）

写链表代码注意的问题：

+ **理解指针或引用的含义**
  
+ **将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。**
  
+ **警惕指针丢失和内存泄漏**

  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313104919.jpeg" alt="img" style="zoom:50%;" />

```c++
x->next = b;
a->next = x;
```

删除链表结点时，也一定要记得手动释放内存空间。

+ **利用哨兵简化实现难度**

  + 针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。

  + 如果我们引入 **哨兵结点** ，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。

    <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313105116.jpeg" alt="img" style="zoom:50%;" />

+ **重点留意边界条件处理**
  + 如果链表为空时，代码是否能正常工作？
  + 如果链表只包含一个结点时，代码是否能正常工作？
  + 如果链表只包含两个结点时，代码是否能正常工作？
  + 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？



**必会代码：**

- 实现单链表、循环链表、双向链表，支持增删操作
- 实现单链表反转
- 实现两个有序的链表合并为一个有序链表
- 实现求链表的中间结点
- 链表中环的检测
- 删除链表倒数第 n 个结点

